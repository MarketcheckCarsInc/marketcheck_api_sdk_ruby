=begin
#Marketcheck Cars API

#<b>Access the New, Used and Certified cars inventories for all Car Dealers in US.</b> <br/>The data is sourced from online listings by over 44,000 Car dealers in US. At any time, there are about 6.2M searchable listings (about 1.9M unique VINs) for Used & Certified cars and about 6.6M (about 3.9M unique VINs) New Car listings from all over US. We use this API at the back for our website <a href='https://www.marketcheck.com' target='_blank'>www.marketcheck.com</a> and our Android and iOS mobile apps too.<br/><h5> Few useful links : </h5><ul><li>A quick view of the API and the use cases is depicated <a href='https://portals.marketcheck.com/mcapi/' target='_blank'>here</a></li><li>The Postman collection with various usages of the API is shared here https://www.getpostman.com/collections/2752684ff636cdd7bac2</li></ul>

OpenAPI spec version: 1.0.3

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.0-SNAPSHOT

=end

require 'spec_helper'
require 'json'
require 'pry'

# Unit tests for Marketcheck_api_sdk::ListingsApi
# Automatically generated by swagger-codegen (github.com/swagger-api/swagger-codegen)
# Please update as you see appropriate
describe 'ListingsApi' do
  before do
    # run before each test
    @api_key = "api key example"
    @instance = Marketcheck_api_sdk::ListingsApi.new
    @search_lease_instance = Marketcheck_api_sdk::ListingLease.new
  end

  after do
    # run after each test
  end
  opts = {api_key: @api_key}
  properties = {
    "listing_id" => %w[4T1B11HK1JU643996-8a68ad13-7ca4-47eb-bc8f-53635b054667 4T1B11HK9JU644619-fe627386-1868-4b3f-9e64-0dd37e96a6c6
    4T1B11HKXJU647545-5766db96-3c3a-49c7-b2f1-80604adb429f JF2GTABC9JH333062-cd9481a0-c474-49cc-90df-9216fed35c10
    ],
    "vin" => %w[1FA6P8TH2F5348583 1FTEX1EP3FKD56744 1FA6P8TH7F5350202 1FTEX1EP8FKD00296 1FDUF4HY7FED44451],
    "year" => %w[2017 2018 2014 2016 2015],
    "make" => %w[Ford Chevrolet Toyota Nissan Honda],
    "model" => %w[F-150 Civic Escape Equinox Malibu],
    "trim" => %w[Base Limited Sport Platinum Touring],
    "exterior_color" => %w[black white silver red blue],
    "interior_color" => %w[black gray graphite cloth ash],
    "body_type" => %w[Sedan Pickup Hatchback Coupe Wagon],
    "body_subtype" => ["Crew Cab", "Extended Cab", "Regular Cab", "Super Cab"],
    "vehicle_type" => %w[SUV Van Car Truck],
    "seller_type" => %w[dealer fsbo],
    "drivetrain" => ["Front Wheel Drive", "4-Wheel Drive", "All Wheel Drive", "Rear Wheel Drive", "4x2"],
    "cylinders" => %w[4 6 8 5 3],
    "transmission" => ["Automatic", "Manual", "Automated Manual", "Direct Drive", "Manual/Standard"],
    "doors" => %w[4 2 5 3 6],
    "engine_block" => %w[v i h],
    "latitude" => %w[35.94 37.34 35.41 33.54 43.06],
    "longitude" => %w[-117.29 -75.65 -86.8 -80.64 -84.16],
    "taxonomy_vins" => %w[1FTEW1EFFF 1FTEW1CPFK 1FTEW1CGFK 1FTEW1EFFK 1FTFW1EGFF],
    "miles_range" => %w[3000 5000 8000 10000],
    "price_range" => %w[30000 40000 50000 60000],
    "dom_range" => %w[20 30 40 50],
    "sort_by" => %w[price miles dom year],
    "stats_fields" => %w[price miles dom],
    "sort_order" => %w[asc desc],
    "rows" => %w[5 10 20 30 50],
    "facets" => %w[year make model trim car_type],
    "dealer_id" => [1007324, 1000466, 1016299, 1016499, 1015942],
    "car_type" => %w[new used],
    "zip" => %w[90001 75209 49519 64114],
    "country" => %w[CA US],
    "lease_term" => [36, 39, 48],
    "lease_emp" => [200, 300, 400],
    "finance_emp" => [200, 300, 400],
    "lease_down_payment" => [1000, 2000, 3000],
    "finance_loan_term" => [36, 48, 72],
    "finance_loan_apr" => [4, 4.5, 4.75, 5],
    "finance_down_payment" => [2000, 3000, 5000],
    
  }
  # unit tests for get_listing
  # Listing by id
  # Get a particular listing by its id
  # @param id Listing id to get all the listing attributes
  # @param [Hash] opts the optional parameters
  # @option opts [String] :api_key The API Authentication Key. Mandatory with all API calls.
  # @return [Listing]
  describe 'test an instance of ListingsApi' do
    it 'validate listing formats' do
      properties["listing_id"].each{ |id|
        opts = { 
          api_key: @api_key, # String | The API Authentication Key. Mandatory with all API calls.
        }
        result = @instance.get_listing(id, opts)
        expect(result).not_to be_nil
        expect(result.media).to be_instance_of(Marketcheck_api_sdk::ListingMedia)
        expect(result.extra).to be_instance_of(Marketcheck_api_sdk::ListingExtraAttributes)
        expect(result.dealer).to be_instance_of(Marketcheck_api_sdk::Dealer)
        expect(result.build).to be_instance_of(Marketcheck_api_sdk::Build)
        expect(result.media.photo_links).to be_instance_of(Array)
        expect(result.extra.seller_comments).to be_instance_of(String)
        expect(result.extra.features).to be_instance_of(Array)
        expect(result.dealer.id  && result.dealer.street && result.dealer.zip).to be_instance_of (String)
      }
      expect(@instance).to be_instance_of(Marketcheck_api_sdk::ListingsApi)
    end
  end
  # unit tests for get_listing_media
  # Listing media by id
  # Get listing media (photo, photos) by id
  # @param id Listing id to get all the listing attributes
  # @param [Hash] opts the optional parameters
  # @option opts [String] :api_key The API Authentication Key. Mandatory with all API calls.
  # @return [ListingMedia]
  describe 'get listing media test' do
    it 'validate media fields in listings' do
      properties["listing_id"].each{ |_listing_id|
        opts = { 
          api_key: @api_key, # String | The API Authentication Key. Mandatory with all API calls.
        }
        result = @instance.get_listing_media(_listing_id, opts)
        expect(result.id).to be_instance_of String
        expect(result.photo_links).to be_instance_of Array
      }
          
      # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
    end
  end
  #  #
  # unit tests for get_listing_extra
  # Long text Listings attributes for Listing with the given id
  # Get listing options, features, seller comments
  # @param id Listing id to get all the long text listing attributes
  # @param [Hash] opts the optional parameters
  # @option opts [String] :api_key The API Authentication Key. Mandatory with all API calls.
  # @return [ListingExtraAttributes]
  describe 'get listing extra test' do
    properties["listing_id"].each{ |_listing_id|
      it 'should validate extra field in listing' do
        opts = { 
          api_key: @api_key, # String | The API Authentication Key. Mandatory with all API calls.
        }
        result = @instance.get_listing_extra(_listing_id, opts)
        expect(result).not_to be_nil
        expect(result.id)
        expect(result.options)
        expect(result.features)
        #expect(result.seller_comments)
        # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
      end
    }
  end
  #
  #  
  #
  # unit tests for search
  # Gets active car listings for the given search criteria
  # This endpoint is the meat of the API and serves many purposes. This API produces a list of currently active cars from the market for the given search criteria. The API results are limited to allow pagination upto 1000 rows.   The search API facilitates the following use cases -  1. Search Cars around a given geo-point within a given radius  2. Search cars for a specific year / make / model or combination of these  3. Search cars matching multiple year, make, model combinatins in the same search request 4. Filter results by most car specification attributes 5. Search for similar cars by VIN or Taxonomy VIN  6. Filter cars within a given price / miles / days on market (dom) range 7. Specify a sort order for the results on price / miles / dom / listed date  8. Search cars for a given City / State combination  9. Get Facets to build the search drill downs  10. Get Market averages for price/miles/dom/msrp for your search
  # @param [Hash] opts the optional parameters
  # @option opts [String] :api_key The API Authentication Key. Mandatory with all API calls.
  # @option opts [Float] :latitude Latitude component of location
  # @option opts [Float] :longitude Longitude component of location
  # @option opts [Integer] :radius Radius around the search location
  # @option opts [String] :zip car search bases on zipcode
  # @option opts [BOOLEAN] :include_lease Boolean param to search for listings that include leasing options in them
  # @option opts [BOOLEAN] :include_finance Boolean param to search for listings that include finance options in them
  # @option opts [String] :lease_term Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term&#x3D;30-60
  # @option opts [String] :lease_down_payment Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment&#x3D;30-60
  # @option opts [String] :lease_emp Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp&#x3D;30-60
  # @option opts [String] :finance_loan_term Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term&#x3D;30-60
  # @option opts [String] :finance_loan_apr Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr&#x3D;30-60
  # @option opts [String] :finance_emp Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp&#x3D;30-60
  # @option opts [String] :finance_down_payment Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment&#x3D;30-60
  # @option opts [String] :finance_down_payment_per Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per&#x3D;30-60
  # @option opts [String] :car_type Car type. Allowed values are - new / used / certified
  # @option opts [String] :seller_type Seller type to filter cars on. Valid filter values are those that our Search facets API returns for unique seller types. You can pass in multiple seller type values comma separated.
  # @option opts [String] :carfax_1_owner Indicates whether car has had only one owner or not
  # @option opts [String] :carfax_clean_title Indicates whether car has clean ownership records
  # @option opts [String] :year Car year - 1980 onwards. Valid filter values are those that our Search facets API returns for unique years. You can pass in multiple year values comma separated.
  # @option opts [String] :make Car Make - should be a standard OEM Make name. Valid filter values are those that our Search facets API returns for unique make. You can pass in multiple make values separated by comma. e.g. ford,audi
  # @option opts [String] :model Car model to search. Valid filter values are those that our Search facets API returns for unique model. You can pass in multiple model values comma separated for e.g f-150,Mustang.
  # @option opts [String] :trim Car trim to search. Valid filter values are those that our Search facets API returns for unique trim. You can pass in multiple trim values comma separated
  # @option opts [String] :dealer_id Dealer id to filter the cars.
  # @option opts [String] :vin Car vin to search
  # @option opts [String] :source Source to search cars. Valid filter values are those that our Search facets API returns for unique source. You can pass in multiple source values comma separated
  # @option opts [String] :body_type Body type to filter the cars on. Valid filter values are those that our Search facets API returns for unique body types. You can pass in multiple body types comma separated.
  # @option opts [String] :body_subtype Body subtype to filter the cars on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
  # @option opts [String] :vehicle_type Vehicle type to filter the cars on. Valid filter values are those that our Search facets API returns for unique vehicle types. You can pass in multiple vehicle type values comma separated
  # @option opts [String] :vins Comma separated list of 17 digit vins to search the matching cars for. Only 10 VINs allowed per request. If the request contains more than 10 VINs the first 10 VINs will be considered. Could be used as a More Like This or Similar Vehicles search for the given VINs. Ths vins parameter is an alternative to taxonomy_vins or ymmt parameters available with the search API. vins and taxonomy_vins parameters could be used to filter our cars with the exact build represented by the vins or taxonomy_vins whereas ymmt is a top level filter that does not filter cars by the build attributes like doors, drivetrain, cylinders, body type, body subtype, vehicle type etc
  # @option opts [String] :taxonomy_vins Comma separated list of 10 letters excert from the 17 letter VIN. The 10 letters to be picked up from the 17 letter VIN are - first 8 letters and the 10th and 11th letter. E.g. For a VIN - 1FTFW1EF3EKE57182 the taxonomy vin would be - 1FTFW1EFEK  A taxonomy VIN identified a build of a car and could be used to filter our cars of a particular build. This is an alternative to the vin or ymmt parameters to the search API.
  # @option opts [String] :ymmt Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe &#39;|&#39; character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - &#39;year|make||&#39; or &#39;year|make|model&#39; or &#39;|make|model|&#39; combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the &#39;vins&#39; or &#39;taxonomy_vins&#39; parameter to the search api instead the year|make|model|trim combinations.
  # @option opts [String] :match Comma separated list of Year, Make, Model, Trim fields. For example - year,make,model,trim fields for which user wants to do an exact match
  # @option opts [String] :cylinders Cylinders to filter the cars on. Valid filter values are those that our Search facets API returns for unique cylinder values. You can pass in multiple cylinder values comma separated
  # @option opts [String] :transmission Transmission to filter the cars on. [a &#x3D; Automatic, m &#x3D; Manual]. Valid filter values are those that our Search facets API returns for unique transmission. You can pass in multiple transmission values comma separated
  # @option opts [String] :speeds Speeds to filter the cars on. Valid filter values are those that our Search facets API returns for unique speeds. You can pass in multiple speeds values comma separated
  # @option opts [String] :doors Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated
  # @option opts [String] :drivetrain Drivetrain to filter the cars on. Valid filter values are those that our Search facets API returns for unique drivetrains. You can pass in multiple drivetrain values comma separated
  # @option opts [String] :exterior_color Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated
  # @option opts [String] :interior_color Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated
  # @option opts [String] :engine Filter listings on engine
  # @option opts [String] :engine_type Engine Type to match. Valid filter values are those that our Search facets API returns for unique engine types. You can pass in multiple engine type values comma separated
  # @option opts [String] :engine_aspiration Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated
  # @option opts [String] :engine_block Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
  # @option opts [String] :miles_range Miles range to filter cars with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000
  # @option opts [String] :price_range Price range to filter cars with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000
  # @option opts [String] :dom_range Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
  # @option opts [String] :sort_by Sort by field - allowed fields are distance|price|miles|dom|age|posted_at|year. Default sort field is distance from the given point
  # @option opts [String] :sort_order Sort order - asc or desc. Default sort order is distance from a point.
  # @option opts [String] :rows Number of results to return. Default is 10. Max is 50
  # @option opts [String] :start Page number to fetch the results for the given criteria. Default is 1. Pagination is allowed only till first 1000 results for the search and sort criteria. The page value can be only between 1 to 1000/rows
  # @option opts [String] :facets The comma separated list of fields for which facets are requested. Supported fields are - year, make, model, trim, vehicle_type, car_type, body_type, body_subtype, drivetrain, cylinders, transmission, exterior_color, interior_color, doors, engine_type, engine_aspiration, engine_block. Facets could be requested in addition to the listings for the search. Please note - The API calls with lots of facet fields may take longer to respond.
  # @option opts [String] :stats The list of fields for which stats need to be generated based on the matching listings for the search criteria. Allowed fields are - price, miles, msrp, dom The stats consists of mean, max, average and count of listings based on which the stats are calculated for the field. Stats could be requested in addition to the listings for the search. Please note - The API calls with the stats fields may take longer to respond.
  # @option opts [String] :country Filter on Country, by default US. Search available on US (United States) and CA (Canada)
  # @option opts [String] :plot If plot has value true results in around 25k coordinates with limited fields to plot respective graph
  # @option opts [BOOLEAN] :nodedup If nodedup is set to true then will give results without is_searchable i.e multiple listings for single vin
  # @option opts [String] :state Filter listsings on State
  # @option opts [String] :city Filter listings on city
  # @option opts [String] :dealer_name Filter listings on dealer_name
  # @option opts [String] :trim_o Filter listings on web scraped trim
  # @option opts [String] :trim_r Filter trim on custom possible matches
  # @option opts [String] :dom_active_range Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
  # @option opts [String] :dom_180_range Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
  # @option opts [String] :options Tokenizer search on options for multiple options use | as seperator
  # @option opts [String] :features Tokenizer search on features for multiple options use | as seperator
  # @option opts [BOOLEAN] :exclude_certified Boolean param to exclude certified cars from search results
  # @return [SearchResponse]
  properties["ym_cmobo"] = properties["year"].product(properties["make"])
  properties["mm_cmobo"] = properties["make"].product(properties["model"])
  properties["mt_cmobo"] = properties["model"].product(properties["trim"])
  properties["ymm_cmobo"] = properties["year"].product(properties["make"], properties["model"])
  properties["ymmt_cmobo"] = properties["year"].product(properties["make"], properties["model"], properties["trim"])
  properties["ext_int_clr_combo"] = properties["exterior_color"].product(properties["interior_color"])
  properties["ext_clr_bd_type_combo"] = properties["exterior_color"].product(properties["body_type"])
  properties["ext_clr_bd_type_combo"] = properties["exterior_color"].product(properties["body_type"])
  properties["ext_clr_bd_and_bds_type_combo"] = properties["exterior_color"].product(properties["body_type"], properties["body_subtype"])
  properties["ext_int_clr_bd_and_bds_type_combo"] = properties["exterior_color"].product(properties["interior_color"], properties["body_type"], properties["body_subtype"])
  properties["seller_and_vehicle_type"] = properties["seller_type"].product(properties["vehicle_type"])
  properties["lat_lng_combo"] = properties["latitude"].product(properties["longitude"])
  properties["vin_combo"] = properties["vin"].product(properties["vin"])
  properties["taxonomy_vins_combo"] = properties["taxonomy_vins"].product(properties["taxonomy_vins"])
  properties["miles_range_combo"] = properties["miles_range"][0..1].product(properties["miles_range"][-2..-1])
  properties["price_range_combo"] = properties["price_range"][0..1].product(properties["price_range"][-2..-1])
  properties["dom_range_combo"] = properties["dom_range"][0..1].product(properties["dom_range"][-2..-1])
  properties["sort_by_and_order_combo"] = properties["sort_by"].product(properties["sort_order"])    
  properties["sort_by_fields_combo"] = properties["sort_by"][0..1].product(properties["sort_by"][-2..-1]).product(properties["sort_order"]).flatten
  misc_fields = []
  all_query_params = []
  misc_fields << ["year="+properties["year"].sample,
    "make="+properties["make"].sample,
    "model="+properties["model"].sample,
    "trim="+properties["trim"].sample,
    "exterior_color="+properties["exterior_color"].sample,
    "interior_color="+properties["interior_color"].sample,
    "body_type="+properties["body_type"].sample
  ]
  #  
  misc_fields.each{ |query_field|
    query_param = ""
    query_field.each{ |field|
      query_param += "&#{field}"
      all_query_params << query_param
    }
  }
  listing_params = ["[0]_listing.build.year"]
  describe 'search test' do
    it 'validate lease_term' do
      properties["lease_term"].each do |l_term|
        opts = {api_key: @api_key , lease_term: l_term}
        result = @instance.search(opts)
        expect(result).not_to be_nil
        result.listings.each{|listing|
          expect(listing.leasing_options.first.lease_term).to eq(l_term)
        }
        # assertion here. ref: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
      end
    end
  end
  #  
  #
  describe "validate lease_emp", focus: true do
    properties["lease_emp"].each do |l_emp|
      it "should validate lease estimated monthly payment" do
        opts = {api_key: @api_key , lease_emp: l_emp}
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.leasing_options.first.estimated_monthly_payment).to eq(l_emp)
        }
      end
    end
  end
  describe "validate lease_down_payment", focus: true do
    properties["lease_down_payment"].each do |l_dp|
      it "should validate lease down payment" do
        opts = {api_key: @api_key , lease_down_payment: l_dp} 
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.leasing_options.first.down_payment).to eq(l_dp)
        }
      end
    end
  end
  describe "validate finance_loan_term", focus: true do
    properties["finance_loan_term"].each do |f_loan|
      it "should validate finance loan term" do
        opts = {finance_loan_term: f_loan , api_key: @api_key}
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.financing_options.first.loan_term).to eq(f_loan)
        }
      end
    end
  end
  describe "validate finance_loan_apr", focus: true do
    properties["finance_loan_apr"].each do |f_loan_apr|
      it "should validate finance loan apr" do
        opts = {finance_loan_apr: f_loan_apr , api_key: @api_key}
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.financing_options.first.loan_apr).to eq(f_loan_apr)
        }
      end
    end
  end
  describe "validate finance_emp", focus: true do
    properties["finance_emp"].each do |f_emp|
      it "should validate finance estimated monthly payment" do
        opts = {finance_emp: f_emp , api_key: @api_key}
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.financing_options.first.estimated_monthly_payment).to eq(f_emp)
        }
      end
    end
  end
  describe "validate finance_down_payment", focus: true do
    properties["finance_down_payment"].each do |f_dp|
      it "should validate finance down payment" do
        opts = {finance_down_payment: f_dp , api_key: @api_key}
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.financing_options.first.down_payment).to eq(f_dp)
        }
      end
    end
  end
  describe "validate lease fields in range and sort order on them", focus: true do
    properties["sort_order"].each do |sort_o|
      ["lease_term","lease_emp","lease_down_payment"].each do |fl|
        it "should validare lease fields range filter and sort order on #{fl} in #{sort_o}" do
          opts = {api_key: @api_key,
            lease_term: '36-48',
            lease_emp: '200-400' , 
            lease_down_payment: '1000-3000' , 
            sort_by: "#{fl}" ,
            sort_order: "#{sort_o}",
            rows: 50,
            car_type: 'used'
          }
              
          result = @instance.search(opts)
          expect(result).not_to be_nil
          field_arr = []
          result.listings.each{ |_listing|
            expect(_listing.leasing_options[0].lease_term).to be <=48
            expect(_listing.leasing_options[0].lease_term).to be >=36
            expect(_listing.leasing_options[0].estimated_monthly_payment).to be <=400
            expect(_listing.leasing_options[0].estimated_monthly_payment).to be >=200
            expect(_listing.leasing_options[0].down_payment).to be <=3000
            expect(_listing.leasing_options[0].down_payment).to be >=1000
            if(fl == "lease_down_payment")
              field_arr << _listing.leasing_options[0].down_payment
            elsif(fl == "lease_emp") 
              field_arr << _listing.leasing_options[0].estimated_monthly_payment
            else
              field_arr << _listing.leasing_options[0].lease_term
            end
          }
          if sort_o == "asc"
            expect(field_arr.compact).to eq(field_arr.compact.sort)
          else
            expect(field_arr.compact).to eq(field_arr.compact.sort.reverse)
          end
        end
      end 
    end
  end
      
  describe "validate finance fields in range and sort order on them", focus: true do
    properties["sort_order"].each do |sort_o|
      ["finance_loan_term","finance_loan_apr","finance_down_payment", "finance_emp"].each do |fl|
        it "should validare lease fields range filter and sort order on #{fl} in #{sort_o}" do
          opts = {api_key: @api_key,
            finance_loan_term: '36-72',
            finance_loan_apr: '4-5',
            finance_emp: '200-300',
            finance_down_payment: '2000-5000',
            sort_by: "#{fl}",
            sort_order: "#{sort_o}",
            rows: 50,
            car_type: 'used'
          }
          result = @instance.search(opts)
          field_arr = []
          result.listings.each{ |_listing|
            expect(_listing.financing_options[0].loan_term).to be <=72
            expect(_listing.financing_options[0].loan_term).to be >=36
            expect(_listing.financing_options[0].estimated_monthly_payment).to be <=300
            expect(_listing.financing_options[0].estimated_monthly_payment).to be >=200
            expect(_listing.financing_options[0].down_payment).to be <=5000
            expect(_listing.financing_options[0].down_payment).to be >=2000
            expect(_listing.financing_options[0].loan_apr).to be <=5
            expect(_listing.financing_options[0].loan_apr).to be >=4
            if(fl == "finance_loan_term")
              field_arr << _listing.financing_options[0].loan_term
            elsif(fl == "finance_emp")
              field_arr << _listing.financing_options[0].estimated_monthly_payment
            elsif(fl == "finance_loan_apr")
              field_arr << _listing.financing_options[0].loan_apr
            else
              field_arr << _listing.financing_options[0].down_payment
            end
          }
          if sort_o == "asc"
            expect(field_arr.compact).to eq(field_arr.compact.sort)
          else
            expect(field_arr.compact).to eq(field_arr.compact.sort.reverse)
          end
        end
      end 
    end
  end
     
  describe "validate stats" do
    properties["stats_fields"].each do |field|
      it "should validate stats keys and data for #{field}" do
        opts= {api_key: @api_key,
          latitude: 39.73,
          longitude: -104.99,
          radius: 200,
          stats: "#{field}",
          start: 0,
          rows: 10,
          sort_by: "#{field}",
          sort_order: "desc",
          car_type: 'used'
        }
        result = @instance.search(opts)
        expect(result.stats[:"#{field}"].keys).to eq([:min, :max, :count, :missing, :sum, :mean, :stddev, :sum_of_squares, :median])
        if field == "price"
          expect(result.listings[0].price).to eq(result.stats[:price][:max])
        end
      end
    end
  end
    
  describe "validate stats with multiple fields given" do
    it "should validate stats when multiple fields stats is requested" do
      opts = {api_key: @api_key,
        latitude: 39.73,
        longitude: -104.99,
        radius: 200,
        stats: "#{properties['stats_fields'].join(',')}",
        start: 0,
        rows: 10,
        car_type: 'used'
      }
      result = @instance.search(opts)
      expect(result.stats.keys).to eq properties["stats_fields"].map{|p| p.to_sym}
    end
  end
        
  describe "Validate carafax attributes" do
    it "should return only listings that have carfax_1_owner set to true and carfax_clean_title set to true" do
      opts = {api_key: @api_key,
        make: 'ford',
        year: '2010',
        carfax_1_owner: 'true',
        carfax_clean_title: 'true'  
      }
      result = @instance.search(opts)
      expect(result.listings).not_to be_empty
      expect(result.listings[0].carfax_1_owner).should be_truthy
    end
  end
  #    
  describe "Validate zip code search" do
    properties["zip"].each do |_zip|
      it "Should validate response to have same zip code as #{_zip}" do
        opts = {api_key: @api_key,
          make: 'ford',
          year: '2010',
          zip: "#{_zip}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.dealer.zip).to eq(_zip)
        }
      end
    end
  end
          
  #  describe "validate near by response" do
  #    it "should validate response in given range of radius and lat long" do
  #      opts = {api_key: @api_key,
  #        latitude: 39.73,
  #        longitude: -104.99,
  #        radius: '200',
  #        car_type: 'used',
  #        sort_by: 'dist',
  #        sort_order: 'desc'
  #      }
  #      result = @instance.search(opts)
  #      expect(result.listings).not_to be_empty
  #      result.listings.each{ |_listing|
  #        binding.pry
  #        expect(_listing.dist).to be <= 200
  #      }
  #    end
  ##end
  ##    
  ##describe "validate sorting order on dist" do
  ##  it "should validate descending sorting order on distance" do
  ##    opts = {api_key: @api_key,
  ##      latitude: 39.73,
  ##      longitude: -104.99,
  ##      radius: 200, 
  ##      sort_order: 'desc',
  ##      car_type: 'used'
  ##    }
  ##    result = @instance.search(opts)
  ##    binding.pry
  ##    #expect(json_body[:listings]).not_to be_empty
  ##    field_arr = []
  ##    json_body[:listings].each{ |_listing| field_arr << _listing[:dist] }
  ##    expect(field_arr.compact).to eq(field_arr.compact.sort.reverse)
  ##  end
  ##end
  ##    
  ##    
  describe "validate years" do
    properties["year"].each {|_year|
      it "should return #{_year} year when searched for #{_year} year" do
        opts = {api_key: @api_key,
          year: _year,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        #expect(json_body[:listings]).not_to be_empty
        expect(result.listings[0].build.year).to eq(_year.to_i)
      end
    }
  end
  #    
  describe "validate multiple years" do
    properties["year"].each_slice(3) {|year1, year2, year3|
      it "should return #{year1}, #{year2}, #{year3} years when searched for #{year1}, #{year2}, #{year3} years" do
        year_param = year3.nil? ? "#{year1},#{year2}" : "#{year1},#{year2},#{year3}"
        opts = {api_key: @api_key,
          year: "#{year_param}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{ |_listing|
          if !year3.nil?
            expect([year1.to_i, year2.to_i, year3.to_i]).to include(_listing.build.year)
          elsif !year2.nil?
            expect([year1.to_i, year2.to_i]).to include(_listing.build.year)
          else
            expect([year1.to_i]).to include(_listing.build.year)
          end
        }
      end
    }
  end
  ##    
  describe "validate makes" do
    properties["make"].each {|make|
      it "should return #{make} make when searched for #{make} make" do
        opts = {api_key: @api_key,
          make: "#{make}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.make).to eq(make)
        }
      end
    }
  end            
  #    
  describe "validate model" do   
    properties["model"].each {|model|
      it "should return model #{model} model when searched for #{model} model" do
        opts = {api_key: @api_key,
          model: "#{model}",
          car_type: 'used',
          sort_by: 'id'
        }
        result = @instance.search(opts)
        #expect(json_body[:listings]).not_to be_empty
        result.listings.each{|listing|
          expect(listing.build.model).to eq(model)
        }
      end
    }
  end    
        
  describe "validate trim" do
    properties["trim"].each {|trim|
      it "should return trim #{trim} cars when searched for #{trim} trim cars" do
        opts = {api_key: @api_key,
          trim: "#{trim}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        #expect(json_body[:listings]).not_to be_empty
        result.listings.each{|listing|
          expect(listing.build.trim).to eq(trim)
        }
      end
    }
  end               
  #    
  describe "validate year and make" do
    properties["ym_cmobo"][0..4].each{ |year, make|
      it "should return year - #{year}, make - #{make} when searched for #{year}, #{make}" do
        opts = {api_key: @api_key,
          year: year,
          make: make,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)   
        #expect(json_body[:listings]).not_to be_empty
        result.listings.each{|listing|
          expect(listing.build.year).to eq(year.to_i)
          expect(listing.build.make).to eq(make)
        }
      end
    }
  end        
  #    
  describe "validate make and model" do    
    properties["mm_cmobo"][0..4].each{ |make, model|
      it "should return make - #{make}, model - #{model} when searched for #{make}, #{model}" do
        opts = {api_key: @api_key,
          make: make,
          model: model,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.make).to eq(make)
          expect(listing.build.model).to eq(model)
        }
      end
    }
  end        
  #    
  describe "validate model and trim" do   
    properties["mt_cmobo"][0..4].each{ |model, trim|
      it "should return model - #{model}, trim - #{trim} when searched for #{model}, #{trim}" do
        opts = {api_key: @api_key,
          model: model,
          trim: trim,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.model).to eq(model)
          expect(listing.build.trim).to eq(trim)
        }
      end
    }
  end          
  ##  #    
  describe "validate year, make and model" do  
    properties["ymm_cmobo"][0..4].each{ |year, make, model|
      it "should return year - #{year}, make - #{make}, model - #{model} when searched for #{year}, #{make}, #{model}" do
        opts = {api_key: @api_key,
          year: year,
          make: make,
          model: model,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.year).to eq(year.to_i)
          expect(listing.build.make).to eq(make)
          expect(listing.build.model).to eq(model)
        }
      end
    }
  end           
  #    
  describe "validate year, make, model and trim" do
    properties["ymmt_cmobo"][0..4].each{ |year, make, model, trim|
      it "should return year - #{year}, make - #{make}, model - #{model}, trim - #{trim} when searched for #{year}, #{make}, #{model}, #{trim}" do
        opts = {api_key: @api_key,
          year: year,
          make: make,
          model: model,
          trim: trim,
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.year).to eq(year.to_i)
          expect(listing.build.make).to eq(make)
          expect(listing.build.model).to eq(model)
          expect(listing.build.trim).to eq(trim)
        }
      end
    }
  end         
         
  describe "validate exterior color" do     
    properties["exterior_color"].each {|exterior_color|
      it "should return #{exterior_color} exterior_color when searched for #{exterior_color} exterior_color" do
        opts = {api_key: @api_key,
          exterior_color: exterior_color
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.exterior_color.downcase).to eq "#{exterior_color}"
        }
      end
    }
  end       
  #  #    
  describe "validate interior color" do     
    properties["interior_color"].each {|interior_color|
      it "should return #{interior_color} interior_color when searched for #{interior_color} interior_color" do
        opts = {api_key: @api_key,
          interior_color: interior_color
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.interior_color.downcase).to eq(interior_color)
        }
      end
    }
  end    
  #      
  describe "validate body type" do   
    properties["body_type"].each {|body_type|
      it "should return #{body_type} body_type when searched for #{body_type} body_type" do
        opts = {api_key: @api_key,
          body_type: body_type
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.body_type).to eq(body_type)
        }
      end
    }
  end      
        
  describe "validate body sub-type" do     
    properties["body_subtype"].each {|body_subtype|
      it "should return #{body_subtype} body_subtype when searched for #{body_subtype} body_subtype" do
        opts = {api_key: @api_key,
          body_subtype: body_subtype
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.build.body_subtype).to eq(body_subtype)
        }
      end
    }
  end    
        
  describe "validate exterior and interior color" do
    properties["ext_int_clr_combo"][0..4].each {|ext_clr, int_clr|
      it "when searched for exterior color - #{ext_clr}, interior color - #{int_clr} it should return exterior color - #{ext_clr}, interior color - #{int_clr}" do
        opts = {api_key: @api_key,
          exterior_color: ext_clr,
          interior_color: int_clr
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.exterior_color.downcase).to eq(ext_clr)
          expect(listing.interior_color.downcase).to eq(int_clr)
        }
      end 
    }
  end
  #      
  describe "validate exterior, interior color and body type" do       
    properties["ext_clr_bd_type_combo"][0..4].each {|ext_clr, bd_type|
      it "when searched for exterior color - #{ext_clr}, body type - #{bd_type} cars it should return #{ext_clr} #{bd_type} cars" do
        opts = {api_key: @api_key,
          exterior_color: ext_clr,
          body_type: bd_type}
          
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.exterior_color.downcase).to eq(ext_clr)
          expect(listing.build.body_type).to eq(bd_type)
        }
      end
    }
  end     
  #      
  describe "validate exterior color, body type and body sub-type" do  
    properties["ext_clr_bd_and_bds_type_combo"][0..4].each {|ext_clr, bd_type, bds_type|
      it "when searched for exterior color - #{ext_clr}, body type - #{bd_type}, body-subtype - #{bds_type} cars it should return #{ext_clr} #{bd_type} #{bds_type} cars" do
          
        opts = {api_key: @api_key,
          exterior_color: ext_clr,
          body_type: bd_type,
          body_subtype: bds_type
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.exterior_color.downcase).to eq(ext_clr.downcase)
          expect(listing.build.body_type).to eq(bd_type.capitalize)
          expect(listing.build.body_subtype).to eq(bds_type)
        }
      end
    }
  end             
  #      
  describe "validate exterior color, interior color, body type and body sub-type" do 
    properties["ext_int_clr_bd_and_bds_type_combo"][0..4].each {|ext_clr, int_clr, bd_type, bds_type|
      it "when searched for exterior color - #{ext_clr}, interior color - #{int_clr}, body type - #{bd_type}, body-subtype - #{bds_type} cars it should return #{ext_clr} #{int_clr} #{bd_type} #{bds_type} cars" do
          
        opts = {api_key: @api_key,
          exterior_color: ext_clr,
          interior_color: int_clr,
          body_type: bd_type,
          body_subtype: bds_type
        }
        result = @instance.search(opts)   
        result.listings.each{|listing|
          expect(listing.exterior_color.downcase).to eq(ext_clr.downcase)
          expect(listing.interior_color.downcase).to eq(int_clr.downcase)
          expect(listing.build.body_type).to eq(bd_type)
          expect(listing.build.body_subtype).to eq(bds_type)}
      end
    }
  end           
        
  describe "validate vehicle type" do 
    properties["vehicle_type"].each {|vehicle_type|
      it "should return #{vehicle_type} vehicle type when query for vehicle type #{vehicle_type}" do
        opts = {api_key: @api_key,
          vehicle_type: vehicle_type,
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.vehicle_type).to eq(vehicle_type)
        }
      end
    }
  end           
  #      
  describe "validate seller type" do 
    properties["seller_type"].each {|seller_type|
      it "should return seller_type #{seller_type} when searched for #{seller_type}" do
        opts = {api_key: @api_key,
          seller_type: seller_type,
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.seller_type).to eq(seller_type)
        }
      end
    }
  end           
  ##      
  describe "validate seller and vehicle type" do      
    properties["seller_and_vehicle_type"].each {|seller_type, vehicle_type|
      it "should return seller_type #{seller_type} vehicle_type #{vehicle_type} when searched for #{seller_type} #{vehicle_type}" do
        opts = {api_key: @api_key,
          vehicle_type: vehicle_type,
          seller_type: seller_type,
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.vehicle_type).to eq(vehicle_type)
          expect(listing.seller_type).to eq(seller_type)
        }
      end
    }
  end      
  ##      
  describe "validate drivetrain" do     
    properties["drivetrain"].each {|drivetrain|
      it "should return drivetrain #{drivetrain} when searched for #{drivetrain}" do
        opts = {api_key: @api_key,
          drivetrain: drivetrain
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.drivetrain).to eq(drivetrain)
        }
      end
    }
  end       

  describe "validate cylinders" do   
    properties["cylinders"].each {|cylinders|
      it "should return cylinders #{cylinders} when searched for #{cylinders}" do
        opts = {api_key: @api_key,
          cylinders: cylinders
        } 
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.cylinders).to eq(cylinders.to_i)
        }  
      end
    }
  end          
  ##      
  describe "validate transmission" do 
    properties["transmission"].each {|transmission|
      it "should return transmission #{transmission} when searched for #{transmission}" do
        opts = {api_key: @api_key,
          transmission: transmission
        } 
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.transmission).to eq(transmission)
        }  
      end
    }
  end           
  #      
  describe "validate doors" do   
    properties["doors"].each {|doors|
      it "should return doors #{doors} when searched for #{doors}" do
        opts = {api_key: @api_key,
          doors: doors
        } 
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.doors).to eq(doors.to_i)
        }  
      end
    }
  end         
  ##     
  describe "validate engine block" do   
    properties["engine_block"].each {|engine_block|
      it "should return engine_block #{engine_block} when searched for #{engine_block}" do
        opts = {api_key: @api_key,
          engine_block: engine_block
        } 
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.build.engine_block).to eq(engine_block.upcase)
        }  
      end
    }
  end          
  #    
  describe "validate lat and lng" do  
    properties["lat_lng_combo"][0..4].each {|latitude, longitude|
      it "should return near by latitude #{latitude} and longitude #{longitude} when searched for #{latitude} #{longitude}" do
        lower_limit_of_lat = latitude.to_i - 3
        upper_limit_of_lat = latitude.to_i + 3
        lower_limit_of_lng = longitude.to_i - 3
        upper_limit_of_lng = longitude.to_i + 3
        #expect(json_body[:listings]).not_to be_empty
        opts = {api_key: @api_key,
          latitude: latitude,
          longitude: longitude,
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect((listing.dealer.latitude).to_i).to be >= lower_limit_of_lat
          expect((listing.dealer.latitude).to_i).to be <= upper_limit_of_lat
          expect((listing.dealer.longitude).to_i).to be >= lower_limit_of_lng
          expect((listing.dealer.longitude).to_i).to be <= upper_limit_of_lng
        }
      end
    }
  end
  #    
  describe "validate vin" do   
    properties["vin"].each {|vin|
      it "should return vin #{vin} when searched for #{vin}" do
        opts = {api_key: @api_key,
          vin: vin
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.vin).to eq(vin)
        }
      end
    }
  end
  ##    
  describe "validate multiple vins" do
    properties["vin_combo"][0..4].each {|vin1, vin2|
      it "should return vins #{vin1}, #{vin2} when searched for #{vin1} #{vin2}" do
        opts = {api_key: @api_key,
          vins: "#{vin1},#{vin2}"
        }
        result = @instance.search(opts)
        is_taxonomy_vins = false
        vins = [vin1, vin2]
        vins.each{|_vin|
          if _vin.size == 10
            is_taxonomy_vins = true
          end
        }
        taxonomy_vins_of_listing = []
        taxonomy_vins_of_request = []
        result.listings.each{ |_listing|
          #next if _listing[:id].nil?
          taxonomy_vins_of_listing << (_listing.vin[0..7] + _listing.vin[9])
        }
                          
        if !is_taxonomy_vins
          vins.each{|_vin|
            taxonomy_vins_of_request << (_vin[0..7] + _vin[9])
          } 
        else
          taxonomy_vins_of_request = vins
        end
                
        taxonomy_vins_of_listing = taxonomy_vins_of_listing.uniq.sort
        taxonomy_vins_of_request = taxonomy_vins_of_request.uniq.sort
        requested_vin_checker = (taxonomy_vins_of_listing - taxonomy_vins_of_request).size      
        expect(requested_vin_checker).to eq 0
      end
    }
  end        
  ##    
  ##            
  describe "validate taxonomy vins" do 
    properties["taxonomy_vins_combo"][0..4].each {|vin1, vin2|
      it "should return taxonomy vins #{vin1}, #{vin2} when searched for #{vin1} #{vin2}" do
        opts = {api_key: @api_key,
          vins: "#{vin1},#{vin2}"
        }
        result = @instance.search(opts)
        is_taxonomy_vins = false
        vins = [vin1, vin2]
        vins.each{|_vin|
          if _vin.size == 10
            is_taxonomy_vins = true
          end
        }
        taxonomy_vins_of_listing = []
        taxonomy_vins_of_request = []
        result.listings.each{ |_listing|
          #next if _listing[:id].nil?
          taxonomy_vins_of_listing << (_listing.vin[0..7] + _listing.vin[9..10])
        }
                          
        if !is_taxonomy_vins
          vins.each{|_vin|
            taxonomy_vins_of_request << (_vin[0..7] + _vin[9..10])
          } 
        else
          taxonomy_vins_of_request = vins
        end
                          
        taxonomy_vins_of_listing = taxonomy_vins_of_listing.uniq.sort
        taxonomy_vins_of_request = taxonomy_vins_of_request.uniq.sort
        requested_vin_checker = (taxonomy_vins_of_listing - taxonomy_vins_of_request).size      
        expect(requested_vin_checker).to eq 0
      end
    }
  end       
        
                
  describe "validate miles range" do
    properties["miles_range_combo"][0..4].each {|mile1, mile2|
      it "should return mile range in between #{mile1} and #{mile2} when searched for range #{mile1}-#{mile2}" do
        opts = {api_key: @api_key,
          miles_range: "#{mile1}-#{mile2}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{ |_listing|
          expect(_listing.miles).to be >= mile1.to_i
          expect(_listing.miles).to be <= mile2.to_i
        }
      end
    }
  end         
       
  ##              
  describe "validate price range" do       
    properties["price_range_combo"][0..4].each {|price1, price2|
      it "should return price range in between #{price1} and #{price2} when searched for range #{price1}-#{price2}" do
        opts = {api_key: @api_key,
          price_range: "#{price1}-#{price2}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{ |_listing|
          expect(_listing.price).to be >= price1.to_i
          expect(_listing.price).to be <= price2.to_i
        }
      end
    }
  end 
  #      
  describe "validate dom range" do    
    properties["dom_range_combo"][0..4].each {|dom1, dom2|
      it "should return price range in between #{dom1} and #{dom2} when searched for range #{dom1}-#{dom2}" do
        opts = {api_key: @api_key,
          dom_range: "#{dom1}-#{dom2}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{ |_listing|
          expect(_listing.dom).to be >= dom1.to_i
          expect(_listing.dom).to be <= dom2.to_i
        }
      end
    }
  end    
        
#  describe "validate sort by and sort order" do
#    properties["sort_by_and_order_combo"].each {|sort_by, sort_order|
#      it "should return sorted order on #{sort_by} and order should be #{sort_order}" do
#        opts = {api_key: @api_key,
#          sort_by: sort_by,
#          sort_order: sort_order,
#          latitude: 37.998,
#          longitude: -84.522,
#          radius: 50,
#          car_type: 'used',
#        }
#        result = @instance.search(opts)
#        field_arr = []
#        if sort_by == "dist" || sort_by == "price" || sort_by == "miles" || sort_by == "dom"   
#          result.listings.each{|_listing|
#            field_arr << _listing[sort_by.to_sym]
#          }     
#        elsif sort_by == "year"
#          result.listings.each{|_listing|
#            next if _listing.build.nil?
#            field_arr << _listing.build.year.to_i
#          }
#        end
#        if sort_order == "asc"
#          expect(field_arr.compact).to eq(field_arr.compact.sort)
#        else
#          expect(field_arr.compact).to eq(field_arr.compact.sort.reverse)
#        end
#      end
#    }
#  end
       
         
  describe "validate rows" do
    properties["rows"].each {|rows|
      it "should return #{rows} rows on query for #{rows}" do
        opts = {api_key: @api_key,
          exterior_color: 'black',
          rows: "#{rows}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'        }
        result = @instance.search(opts)
        expect(result.listings.size).to eq(rows.to_i)
      end
    }
  end
                  
      
  describe "validate ymmt module" do
    properties["ymmt_cmobo"][0..4].each{ |year, make, model, trim|
      ymmt_tokens = "#{year}|#{make}|#{model}"
      it "should return year - #{year}, make - #{make}, model - #{model} when searched for #{year}, #{make}, #{model}" do
        opts = {api_key: @api_key,
          year: "#{year}",
          ymmt: "#{ymmt_tokens}",
          latitude: 37.998,
          longitude: -84.522,
          radius: 50,
        }
        result = @instance.search(opts)
        expect(result.listings[0].build.year).to eq(year.to_i)
        expect(result.listings[0].build.make).to eq(make)
        expect(result.listings[0].build.model).to eq(model)
      end
    }
  end
  ##          
  describe "validate misc fields" do
    all_query_params.each{ |query_param|
      tokens = query_param[1..-1].split("&")
      token_types = tokens.map{ |_token|
        _token.split("=")[0]
      }
      token_vals = tokens.map{ |_token|
        _token.split("=")[1]
      }
             
      it "should return #{tokens} when searched for #{tokens}" do
        if token_types.size == 1
          opts = {api_key: "#{@api_key}",
            year: "#{token_vals[0]}",
            latitude: 37.998,
            longitude: -84.522,
            radius: 50,       }
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
        elsif
          token_types.size == 2
          opts[:make] = "#{token_vals[1]}"
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
          expect(result.listings[0].build.make).to eq(token_vals[1])
        elsif
          token_types.size == 3
          opts[:model] = "#{token_vals[2].downcase}"
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
          expect(result.listings[0].build.make).to eq(token_vals[1])
          expect(result.listings[0].build.model).to eq(token_vals[2])
        elsif
          token_types.size ==  4
          opts[:trim] = "#{token_vals[3].downcase}"
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
          expect(result.listings[0].build.make).to eq(token_vals[1])
          expect(result.listings[0].build.model).to eq(token_vals[2])
          expect(result.listings[0].build.trim).to eq(token_vals[3])
        elsif
          token_types.size ==  5
          opts[:exterior_color] = "#{token_vals[4]}"
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
          expect(result.listings[0].build.make).to eq(token_vals[1])
          expect(result.listings[0].build.model).to eq(token_vals[2])
          expect(result.listings[0].build.trim).to eq(token_vals[3])
          expect(result.listings[0].build.exterior_color).to eq(token_vals[4])
        elsif
          token_types.size == 6
          opts[:interior_color] = "#{token_vals[5]}"
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.listings[0].build.year).to eq(token_vals[0].to_i)
          expect(result.listings[0].build.make).to eq(token_vals[1])
          expect(result.listings[0].build.model).to eq(token_vals[2])
          expect(result.listings[0].build.trim).to eq(token_vals[3])
          expect(result.listings[0].build.exterior_color).to eq(token_vals[4])
          expect(result.listings[0].build.interior_color).to eq(token_vals[5])
        end
      end
    }
  end
  #      
  describe "validate facets" do
    properties["facets"].each_with_index{ |facet_field, index|
      facets_param = properties["facets"][index..(index+1)].join(',')
      it "should be facet on #{facets_param}" do
        facets_param.split(',').each{ |field|
          opts = {api_key: @api_key,
            facets: "#{facets_param}",
            latitude: 37.998,
            longitude: -84.522,
            radius: 50,
          }
          result = @instance.search(opts)
          expect(result.num_found).should be > 0
          expect(result.num_found).to be_instance_of(Fixnum)
          expect(result.listings).to be_instance_of(Array)
          expect(result.facets).to be_instance_of(Hash)
          result.facets.keys.each{|key|
            result.facets[:"#{key}"].each{|field|
              expect(field[:item]).to be_instance_of(String)
              expect(field[:count]).to be_instance_of(Fixnum)
            }
          }
        }
      end
    }
  end
        
  describe "validate dealer id" do 
    properties["dealer_id"].each {|dealer_id|
      it "should return dealer id  #{dealer_id} when searched for #{dealer_id}" do
        opts = {api_key: @api_key,
          dealer_id: "#{dealer_id}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.dealer.id).to eq(dealer_id)   
        }
      end
    }
  end   
  #      
  #  describe "validate api response for matching vins" do 
  #    properties["vin"].each {|_vin|
  #      it "should validate response should not be null" do
  #        opts = {api_key: @api_key,
  #          vins: "#{_vin}",
  #          match: 'year,make,model,trim',
  #          latitude: 40.85271900000001,
  #          longitude: 74.0623244,
  #          radius: 5000,
  #          car_type: 'used',
  #          sort_by: 'dist',
  #          sort_order: 'asc',
  #          start: 0,
  #          rows: 50,
  #          country: 'All'
  #        }
  #        result = @instance.search(opts)
  #        binding.pry
  #        expect(result.listings).not_to be_empty
  #        expect_json_keys([:num_found, :listings])
  #        expect_json_types(num_found: :integer, listings: :array_of_objects)
  #      end
  #    }
  #  end  
  #      
  describe "validate inventory type" do 
    properties["car_type"].each {|_car_type|
      it "should return inventory type  #{_car_type} when searched for #{_car_type}" do
        opts = {api_key: @api_key,
          car_type: 'used',
          latitude: 37.998,
          longitude: -84.522,
          radius: 50,
        }
        result = @instance.search(opts)
        expect(result).not_to be_nil
        result.listings.each{|listing|
          expect(listing.inventory_type).to eq 'used'
        }
      end
    }
  end 
        
  describe "validate country" do 
    properties["country"].each {|_country|
      it "should return country  #{_country} when searched for #{_country}" do
        opts = {api_key: @api_key,
          country: "#{_country}",
          car_type: 'used',
          sort_by: 'id',
          sort_order: 'desc'
        }
        result = @instance.search(opts)
        result.listings.each{|listing|
          expect(listing.dealer.country.upcase).to eq "#{_country}"
        }
      end
    }
  end
end